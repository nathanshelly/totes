#! /usr/bin/env bash

# ref - https://stackoverflow.com/a/3601734
[[ -n "$1" ]] && optional_subject="$1"

# print usage information
help() {
  cat << EOF
usage: totes [subject] [options]

  --help           Show this help text
  --list-subjects  List all available subjects
EOF
}

# get path to notes directory
get_notes_path() {
  # location based on XDG directory specification
  # ref - https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html
  local notes_path="${XDG_DATA_HOME:-$HOME/.local/share}/totes"
  if ! [[ -d $notes_path ]]; then
    printf "The notes directory - %s - does not exist.\n" "$notes_path" >&2
    # shellcheck disable=2016
    printf 'Try running the `install.sh` script again\n' >&2
    # checks if this script is in a repo (should be true if it is symlinked)
    if git rev-parse HEAD > /dev/null 2>&1; then
      # display full path to install script if we can find it
      printf "path: %s/install.sh\n" "$(git rev-parse --show-toplevel)" >&2
    fi
    exit 1
  fi
  printf "%s" "$notes_path"
}

# get list of notes for current session (filtered by subject, supressed status,
# etc.)
get_all_notes() {
  local notes_path
  notes_path="$(get_notes_path)" || exit $?
  if [[ -n "$optional_subject" ]]; then
    if ! ls "$notes_path/$optional_subject"/*.md > /dev/null 2>&1; then
      printf "No notes exist for subject '%s' @ '%s'\n" \
        "$optional_subject" \
        "$notes_path" \
        >&2
      exit 1
    fi

    printf "%s" "$(ls -At -- "$notes_path/$optional_subject"/*.md)"
  else
    printf "%s" "$(ls -At -- "$notes_path"/**/*.md)"
  fi
}

# get full path to list of suppressed notes
get_suppressed_note_registry_spec() {
  printf "%s/suppressed_note_registry" "$(get_notes_path)" || exit $?
}

# add given note to suppressed registry
suppress_note() {
  printf "%s\n" "$1" >> "$(get_suppressed_note_registry_spec)" || exit $?
}

# determine the next note to render
get_note_to_render() {
  local suppressed_note_registry_spec all_notes note_to_render
  suppressed_note_registry_spec="$(get_suppressed_note_registry_spec)" || exit $?
  all_notes="$(get_all_notes)" || exit $?
  if [[ -f "$suppressed_note_registry_spec" ]]; then
    # `active_notes` must be declared here (instead of at the start of this
    # function) for the `${active_notes-$all_notes}` expansion to work
    local active_notes
    # filter out notes with a match in the registry
    active_notes="$(grep -vFf "$suppressed_note_registry_spec" <<< "$all_notes")"
  fi
  # `tail` `active_notes` if it's non-null else `all_notes`
  # ref - https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_02
  note_to_render="$(tail -n 1 <<< "${active_notes-$all_notes}")"
  if [[ -z $note_to_render ]]; then
    printf "No note found. They've likely all been removed from rotation.\n" >&2
    printf "Add new notes, or modify/delete '%s' to view notes again.\n" \
      "$suppressed_note_registry_spec" >&2
    exit 1
  fi
  printf "%s" "$note_to_render"
}

# render the given note using the best available command
render_single_note() {
  note="$1"
  if command -v mdcat > /dev/null; then
    mdcat "$note" | less --no-init --quit-if-one-screen --RAW-CONTROL-CHARS
  elif command -v bat > /dev/null; then
    bat "$note"
  else
    cat "$note"
  fi
}

make_new_note_spec() {
  old_file_spec=$1
  new_file_name=$2

  # Select for everything before what comes between the final slash and the '.md' at the end
  re="(.*\/)[^\/]*\.md$"
  if [[ $old_file_spec =~ $re ]]; then
    printf "%s%s.md" "${BASH_REMATCH[1]}" "$new_file_name"
  else
    printf "problem passing input=%s" "$old_file_spec" >&2
    exit 1
  fi
}

# render the next note
render_next_note() {
  note_to_render="$(get_note_to_render)" || exit $? # propagate errors
  render_single_note "$note_to_render"
}

# non-rendering ux of `totes`
handle_user_input() {
  printf "%s" "--> (n)ext | (q)uit | (r)emove & next | (e)dit | (c)reate new note | (x) save & quit --> "
  read -r -n 1 user_action < /dev/tty
  echo

  # ref - https://stackoverflow.com/a/37408702
  if ! [[ "$user_action" =~ ^(x|X)$ ]]; then
    touch "$note_to_render" # update last read time to cycle through notes
  fi

  case $user_action in
    n | N)
      totes "$@" # propagate arguments
      ;;
    e | E)
      if [[ -z "$EDITOR" ]]; then
        printf "No value for \$EDITOR is set, so unable to edit the requested note.\n"
        exit 0
      fi
      "$EDITOR" "$note_to_render"
      # Date format: [[CC]YY]MMDDhhmm[.ss]
      # Setting to 1:01 on jan 1, 2001, so that it's the earliest note, and so shows up next
      touch -t 0101010101 "$note_to_render"
      totes "$@"
      ;;
    c | C)
      if [[ -z "$EDITOR" ]]; then
        printf "No value for \$EDITOR is set, so unable to create a new note.\n"
        exit 0
      fi
      printf "%s" "--> Enter a filename (with no extension) for this new note: "
      read -r file_name < /dev/tty
      if [[ -z "$file_name" ]]; then
        printf "No name for new note was provided.\n"
        exit 1
      fi
      new_note_spec=$(make_new_note_spec "$note_to_render" "$file_name") || exit $?
      "$EDITOR" "$new_note_spec"
      touch -t 0101010101 "$new_note_spec"
      totes "$@"
      ;;
    r | R)
      suppress_note "$note_to_render"
      totes "$@"
      ;;
    x | X) ;;
    *) ;;
  esac
}

# handle any arguments/flags
parse_input() {
  for opt in "$@"; do
    case $opt in
      --help)
        help
        exit 0
        ;;
      --list-subjects)
        local notes_path
        notes_path="$(get_notes_path)" || exit $?
        find "$notes_path"/* -type d -exec basename {} \;
        exit 0
        ;;
      --*)
        printf "unknown option: %s\n\n" "$opt"
        help
        exit 1
        ;;
    esac
  done

  # standard behavior (flags above may skip this)
  echo
  render_next_note
  echo

  handle_user_input "$@"
}

parse_input "$@"
